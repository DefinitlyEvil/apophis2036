//This Perlin noise implementation is based of the NVidia GPU Gems 2 article
//"Implementing Improved Perlin Noise" (Chapter 26) and the associated code.
//It has been modified to be valid Cg (rather than HLSL), to avoid naming 
//conflicts, and to load the permutations and gradients from texture rather
//than having them generated by the HLSL virtual machine (hence textures
//come in the [0.0,1.0] range, rather than the [-1.0,+1.0] range). The output
//is still in the [-1.0,+1.0] range.

uniform sampler1D g_perlinPermutationsSampler;
uniform sampler1D g_perlinGradients3dSampler;
uniform sampler1D g_perlinGradients4dSampler;

float3 perlinNoiseFade(float3 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10); // new curve
//	return t * t * (3 - 2 * t); // old curve
}

float4 perlinNoiseFade(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10); // new curve
//	return t * t * (3 - 2 * t); // old curve
}

float perlinNoisePerm(float x)
{
	return tex1D(g_perlinPermutationsSampler, x).x;
}

float perlinNoiseGrad(float x, float3 p)
{
	float3 sample = tex1D(g_perlinGradients3dSampler, x).xyz;
	sample = (sample * 2.0) - 1.0; //Because for storing in our image we converted to the 0.0-1.0 range
	return dot(sample, p);
}

float perlinNoiseGrad(float x, float4 p)
{
	float4 sample = tex1D(g_perlinGradients4dSampler, x);
	sample = (sample * 2.0) - 1.0; //Because for storing in our image we converted to the 0.0-1.0 range
	return dot(sample, p);
}

float perlinNoise3d(float3 p, uniform sampler1D perlinPermutationsSampler, uniform sampler1D perlinGradients3dSampler)
{
	g_perlinPermutationsSampler = perlinPermutationsSampler;
	g_perlinGradients3dSampler = perlinGradients3dSampler;
	
	float3 P = fmod(floor(p), 256.0);	// FIND UNIT CUBE THAT CONTAINS POINT
  	p -= floor(p);                      // FIND RELATIVE X,Y,Z OF POINT IN CUBE.
	float3 f = perlinNoiseFade(p);                 // COMPUTE FADE CURVES FOR EACH OF X,Y,Z.

	P = P / 256.0;
	const float one = 1.0 / 256.0;
	
    // HASH COORDINATES OF THE 8 CUBE CORNERS
  	float A = perlinNoisePerm(P.x) + P.y;
  	float4 AA;
  	AA.x = perlinNoisePerm(A) + P.z;
	AA.y = perlinNoisePerm(A + one) + P.z;
  	float B =  perlinNoisePerm(P.x + one) + P.y;
  	AA.z = perlinNoisePerm(B) + P.z;
  	AA.w = perlinNoisePerm(B + one) + P.z;
 
	// AND ADD BLENDED RESULTS FROM 8 CORNERS OF CUBE
  	return lerp( lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AA.x    ), p ),  
                             perlinNoiseGrad(perlinNoisePerm(AA.z    ), p + float3(-1, 0, 0) ), f.x),
                       lerp( perlinNoiseGrad(perlinNoisePerm(AA.y    ), p + float3(0, -1, 0) ),
                             perlinNoiseGrad(perlinNoisePerm(AA.w    ), p + float3(-1, -1, 0) ), f.x), f.y),
                             
                 lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AA.x+one), p + float3(0, 0, -1) ),
                             perlinNoiseGrad(perlinNoisePerm(AA.z+one), p + float3(-1, 0, -1) ), f.x),
                       lerp( perlinNoiseGrad(perlinNoisePerm(AA.y+one), p + float3(0, -1, -1) ),
                             perlinNoiseGrad(perlinNoisePerm(AA.w+one), p + float3(-1, -1, -1) ), f.x), f.y), f.z);
}

float perlinNoise4d(float4 p, uniform sampler1D perlinPermutationsSampler, uniform sampler1D perlinGradients4dSampler)
{
	g_perlinPermutationsSampler = perlinPermutationsSampler;
	g_perlinGradients4dSampler = g_perlinGradients4dSampler;
	
	float4 P = fmod(floor(p), 256.0);	// FIND UNIT HYPERCUBE THAT CONTAINS POINT
  	p -= floor(p);                      // FIND RELATIVE X,Y,Z OF POINT IN CUBE.
	float4 f = perlinNoiseFade(p);                 // COMPUTE FADE CURVES FOR EACH OF X,Y,Z, W
	P = P / 256.0;
	const float one = 1.0 / 256.0;
	
    // HASH COORDINATES OF THE 16 CORNERS OF THE HYPERCUBE
  	float A = perlinNoisePerm(P.x) + P.y;
  	float AA = perlinNoisePerm(A) + P.z;
  	float AB = perlinNoisePerm(A + one) + P.z;
  	float B =  perlinNoisePerm(P.x + one) + P.y;
  	float BA = perlinNoisePerm(B) + P.z;
  	float BB = perlinNoisePerm(B + one) + P.z;

	float AAA = perlinNoisePerm(AA)+P.w, AAB = perlinNoisePerm(AA+one)+P.w;
    float ABA = perlinNoisePerm(AB)+P.w, ABB = perlinNoisePerm(AB+one)+P.w;
    float BAA = perlinNoisePerm(BA)+P.w, BAB = perlinNoisePerm(BA+one)+P.w;
    float BBA = perlinNoisePerm(BB)+P.w, BBB = perlinNoisePerm(BB+one)+P.w;

	// INTERPOLATE DOWN
  	return lerp(
  				lerp( lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AAA), p ),  
                                  perlinNoiseGrad(perlinNoisePerm(BAA), p + float4(-1, 0, 0, 0) ), f.x),
                            lerp( perlinNoiseGrad(perlinNoisePerm(ABA), p + float4(0, -1, 0, 0) ),
                                  perlinNoiseGrad(perlinNoisePerm(BBA), p + float4(-1, -1, 0, 0) ), f.x), f.y),
                                  
                      lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AAB), p + float4(0, 0, -1, 0) ),
                                  perlinNoiseGrad(perlinNoisePerm(BAB), p + float4(-1, 0, -1, 0) ), f.x),
                            lerp( perlinNoiseGrad(perlinNoisePerm(ABB), p + float4(0, -1, -1, 0) ),
                                  perlinNoiseGrad(perlinNoisePerm(BBB), p + float4(-1, -1, -1, 0) ), f.x), f.y), f.z),
                            
  				 lerp( lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AAA+one), p + float4(0, 0, 0, -1)),
                                   perlinNoiseGrad(perlinNoisePerm(BAA+one), p + float4(-1, 0, 0, -1) ), f.x),
                             lerp( perlinNoiseGrad(perlinNoisePerm(ABA+one), p + float4(0, -1, 0, -1) ),
                                   perlinNoiseGrad(perlinNoisePerm(BBA+one), p + float4(-1, -1, 0, -1) ), f.x), f.y),
                                   
                       lerp( lerp( perlinNoiseGrad(perlinNoisePerm(AAB+one), p + float4(0, 0, -1, -1) ),
                                   perlinNoiseGrad(perlinNoisePerm(BAB+one), p + float4(-1, 0, -1, -1) ), f.x),
                             lerp( perlinNoiseGrad(perlinNoisePerm(ABB+one), p + float4(0, -1, -1, -1) ),
                                   perlinNoiseGrad(perlinNoisePerm(BBB+one), p + float4(-1, -1, -1, -1) ), f.x), f.y), f.z), f.w);
}